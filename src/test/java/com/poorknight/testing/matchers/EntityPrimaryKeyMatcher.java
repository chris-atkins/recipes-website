package com.poorknight.testing.matchers;

import java.lang.reflect.Field;

import javax.persistence.GeneratedValue;
import javax.persistence.Id;

import org.hamcrest.Description;
import org.hamcrest.Factory;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeDiagnosingMatcher;


public class EntityPrimaryKeyMatcher extends TypeSafeDiagnosingMatcher<Class<?>> {

	private AttributeAnnotationMatcher idAttributeVerifier = null;


	private EntityPrimaryKeyMatcher() {
		super();
		final Matcher<Field> idLongFieldVerifier = CustomMatchers.isFieldOfType(Long.class);
		final Matcher<Field> idIsAutoGeneratedFieldVerifier = CustomMatchers.hasAnnotationOnField(GeneratedValue.class);
		final Matcher<Field> generatedFieldUsesCorrectStrategyVerifier = CustomMatchers.hasCorrectStrategyOnGeneratedFieldAnnotation();

		this.idAttributeVerifier = CustomMatchers.hasAnnotationOnExactlyOneAttribute(Id.class, idLongFieldVerifier, idIsAutoGeneratedFieldVerifier,
				generatedFieldUsesCorrectStrategyVerifier);
	}


	@Override
	public void describeTo(final Description description) {
		description.appendText("has a single field of type Long that is annotated as the primary key for this class, and is auto-generated.");
	}


	@Override
	protected boolean matchesSafely(final Class<?> classToInspect, final Description mismatchDescription) {

		if (doesNotContainSingleIdAttributeOfTypeLong(classToInspect, mismatchDescription)) {
			// message will be applied as child matchers are called by the above method
			return false;
		}
		return true;
	}


	private boolean doesNotContainSingleIdAttributeOfTypeLong(final Class<?> classToInspect, final Description mismatchDescription) {
		return !(this.idAttributeVerifier.matchesSafely(classToInspect, mismatchDescription));
	}


	@Factory
	public static EntityPrimaryKeyMatcher hasValidPrimaryKey() {
		return new EntityPrimaryKeyMatcher();
	}

}
