package com.poorknight.testing.matchers.fields;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.util.Map;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

import org.hamcrest.Description;
import org.hamcrest.Factory;
import org.hamcrest.TypeSafeDiagnosingMatcher;

import com.poorknight.utils.ReflectionUtils;


public class FieldAnnotationValueMatcher extends TypeSafeDiagnosingMatcher<Field> {

	private final Class<? extends Annotation> annotationClass;
	private final String annotationFieldName;
	private final Object annotationFieldValue;


	private FieldAnnotationValueMatcher(final Class<? extends Annotation> annotationClass, final String annotationFieldName,
			final Object annotationFieldValue) {
		super();
		this.annotationClass = annotationClass;
		this.annotationFieldName = annotationFieldName;
		this.annotationFieldValue = annotationFieldValue;
	}


	@Factory
	public static FieldAnnotationValueMatcher hasAnnotationWithFieldOfValue(final Class<? extends Annotation> annotationClass,
			final String annotationFieldName, final Object annotationFieldValue) {
		return new FieldAnnotationValueMatcher(annotationClass, annotationFieldName, annotationFieldValue);
	}


	@Factory
	public static FieldAnnotationValueMatcher isAnIdentityAutoGeneratedEntityField() {
		return new FieldAnnotationValueMatcher(GeneratedValue.class, "strategy", GenerationType.IDENTITY);
	}


	@Override
	public void describeTo(final Description description) {
		description.appendText("The field has an annotation of type @").appendText(this.annotationClass.getSimpleName()).appendText(" with a ")
				.appendText(this.annotationFieldName).appendText(" field that has a value of ").appendText(this.annotationFieldValue.toString());
	}


	@Override
	protected boolean matchesSafely(final Field fieldToCheck, final Description mismatchDescription) {

		if (fieldDoesNotHaveAnnotation(fieldToCheck)) {
			appendNoAnnotationExistsMessage(mismatchDescription, fieldToCheck);
			return false;
		}

		if (fieldValueDoesNotMatchExpected(fieldToCheck)) {
			appendFieldValueDoesNotMatchMessage(mismatchDescription, fieldToCheck);
			return false;
		}

		return true;
	}


	private boolean fieldDoesNotHaveAnnotation(final Field fieldToCheck) {
		return !(ReflectionUtils.fieldHasAnnotation(fieldToCheck, this.annotationClass));
	}


	private boolean fieldValueDoesNotMatchExpected(final Field fieldToCheck) {
		return !(getActualValue(fieldToCheck).equals(this.annotationFieldValue));
	}


	private void appendNoAnnotationExistsMessage(final Description mismatchDescription, final Field fieldToCheck) {
		mismatchDescription.appendText("The ").appendText(fieldToCheck.getName()).appendText(" does not have an @")
				.appendText(this.annotationClass.getSimpleName()).appendText(" annotation.");
	}


	private void appendFieldValueDoesNotMatchMessage(final Description mismatchDescription, final Field fieldToCheck) {
		mismatchDescription.appendText("The ").appendText(fieldToCheck.getName()).appendText(" annotation @")
				.appendText(this.annotationClass.getSimpleName()).appendText(" does not have the expected value of ")
				.appendText(this.annotationFieldValue.toString()).appendText(". Value found: ").appendText(getActualValue(fieldToCheck).toString());
	}


	private Object getActualValue(final Field fieldToCheck) {
		final Annotation proxyAnnotation = fieldToCheck.getAnnotation(this.annotationClass);

		final InvocationHandler annotationHandler = ReflectionUtils.getFieldFromObject(proxyAnnotation, "h");
		final Map<String, Object> memberValues = ReflectionUtils.getFieldFromObject(annotationHandler, "memberValues");

		return memberValues.get(this.annotationFieldName);
	}
}
