package com.poorknight.testing.matchers.fields;

import static com.poorknight.testing.matchers.CustomMatchers.hasFactoryMethod;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;

import java.lang.reflect.Field;

import javax.persistence.Column;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

import org.hamcrest.Description;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import com.poorknight.testing.matchers.utils.testclasses.ClassWithColumnAnnotations;
import com.poorknight.utils.ReflectionUtils;


@RunWith(JUnit4.class)
public class FieldAnnotationValueMatcherTest {

	final FieldAnnotationValueMatcher matcher = FieldAnnotationValueMatcher.hasAnnotationWithFieldOfValue(Column.class, "name", "columnName");


	@Test
	public void usesFactoryMethod() throws Exception {
		assertThat(FieldAnnotationMatcher.class, hasFactoryMethod());
	}


	@Test
	public void returnsTrueWithCorrectValues() throws Exception {

		final Field field = getField("fieldWithColumnAndName", ClassWithColumnAnnotations.class);
		final boolean results = this.matcher.matchesSafely(field, Description.NONE);

		assertThat(results, equalTo(true));
	}


	private Field getField(final String fieldName, final Class<?> classToInspect) throws Exception {
		return classToInspect.getField(fieldName);
	}


	@Test
	public void returnsTrueWithDifferentDataType() throws Exception {
		final FieldAnnotationValueMatcher differentMatcher = FieldAnnotationValueMatcher.hasAnnotationWithFieldOfValue(Column.class, "precision", 55);

		final Field field = getField("fieldWithColumnAndPrecision", ClassWithColumnAnnotations.class);
		final boolean results = differentMatcher.matchesSafely(field, Description.NONE);

		assertThat(results, equalTo(true));
	}


	@Test
	public void returnsFalseWithNoAnnotationExisting() throws Exception {

		final Field field = getField("fieldWithNoColumn", ClassWithColumnAnnotations.class);
		final boolean results = this.matcher.matchesSafely(field, Description.NONE);

		assertThat(results, equalTo(false));
	}


	@Test
	public void returnsFalseWithNoValueSetInAnnotation() throws Exception {

		final Field field = getField("fieldWithColumnAndNoName", ClassWithColumnAnnotations.class);
		final boolean results = this.matcher.matchesSafely(field, Description.NONE);

		assertThat(results, equalTo(false));
	}


	@Test
	public void returnsFalseWhenDifferentValueSetInAnnotation() throws Exception {

		final Field field = getField("fieldWithColumnAndWrongName", ClassWithColumnAnnotations.class);
		final boolean results = this.matcher.matchesSafely(field, Description.NONE);

		assertThat(results, equalTo(false));
	}


	@Test
	public void theSpecialFactoryMethodUsesTheCorrectParameters() throws Exception {
		final FieldAnnotationValueMatcher identityMatcher = FieldAnnotationValueMatcher.isAnIdentityAutoGeneratedEntityField();

		final Class<?> actualAnnotationClass = ReflectionUtils.getFieldFromObject(identityMatcher, "annotationClass");
		final String actualAnnotationFieldName = ReflectionUtils.getFieldFromObject(identityMatcher, "annotationFieldName");
		final GenerationType actualAnnotationFieldValue = ReflectionUtils.getFieldFromObject(identityMatcher, "annotationFieldValue");

		assertThat(actualAnnotationClass.getCanonicalName(), is(GeneratedValue.class.getCanonicalName()));
		assertThat(actualAnnotationFieldName, is("strategy"));
		assertThat(actualAnnotationFieldValue, is(GenerationType.IDENTITY));
	}
}
